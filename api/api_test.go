package api

import (
	"bytes"
	"fmt"
	"strings"
	"testing"
)

func TestToUnicode(t *testing.T) {
	data := []struct {
		in, out string
	}{
		{"{\\o}", "ø"},
		{"{\\O}", "Ø"},
		{"{\\`A}", "À"},
		{"{\\'A}", "Á"},
		{"{\\^A}", "Â"},
		{"{\\~A}", "Ã"},
		{"{\\\"A}", "Ä"},
		{"{\\AA}", "Å"},
		{"{\\AE}", "Æ"},
		{"{\\c{C}}", "Ç"},
		{"{\\c C}", "Ç"},
		{"{\\`E}", "È"},
		{"{\\'E}", "É"},
		{"{\\^E}", "Ê"},
		{"{\\\"E}", "Ë"},
		{"{\\`I}", "Ì"},
		{"{\\'I}", "Í"},
		{"{\\^I}", "Î"},
		{"{\\\"I}", "Ï"},
		{"{\\~N}", "Ñ"},
		{"{\\`O}", "Ò"},
		{"{\\'O}", "Ó"},
		{"{\\^O}", "Ô"},
		{"{\\~O}", "Õ"},
		{"{\\\"O}", "Ö"},
		{"{\\OE}", "Œ"},
		{"{\\`U}", "Ù"},
		{"{\\'U}", "Ú"},
		{"{\\^U}", "Û"},
		{"{\\\"U}", "Ü"},
		{"{\\'Y}", "Ý"},
		{"{\\\"Y}", "Ÿ"},
		{"{\\ss}", "ß"},
		{"{\\`a}", "à"},
		{"{\\'a}", "á"},
		{"{\\^a}", "â"},
		{"{\\~a}", "ã"},
		{"{\\\"a}", "ä"},
		{"{\\aa}", "å"},
		{"{\\ae}", "æ"},
		{"{\\c{c}}", "ç"},
		{"{\\c c}", "ç"},
		{"{\\`e}", "è"},
		{"{\\'e}", "é"},
		{"{\\^e}", "ê"},
		{"{\\\"e}", "ë"},
		{"{\\`\\i}", "ı̀"},
		{"{\\'\\i}", "ı́"},
		{"{\\^\\i}", "ı̂"},
		{"{\\\"\\i}", "ı̈"},
		{"{\\~n}", "ñ"},
		{"{\\`o}", "ò"},
		{"{\\'o}", "ó"},
		{"{\\^o}", "ô"},
		{"{\\~o}", "õ"},
		{"{\\\"o}", "ö"},
		{"{\\oe}", "œ"},
		{"{\\`u}", "ù"},
		{"{\\'u}", "ú"},
		{"{\\^u}", "û"},
		{"{\\\"u}", "ü"},
		{"{\\'y}", "ý"},
		{"{\\\"y}", "ÿ"},
		{"\\`{A}", "À"},
		{"\\'{A}", "Á"},
		{"\\^{A}", "Â"},
		{"\\~{A}", "Ã"},
		{"\\\"{A}", "Ä"},
		{"\\k{A}", "Ą"},
		{"\\AE{}", "Æ"},
		{"\\AE ", "Æ"},
		{"\\`{E}", "È"},
		{"\\'{E}", "É"},
		{"\\^{E}", "Ê"},
		{"\\\"{E}", "Ë"},
		{"\\k{E}", "Ę"},
		{"\\c{C}", "Ç"},
		{"\\c C", "Ç"},
		{"\\`{I}", "Ì"},
		{"\\'{I}", "Í"},
		{"\\^{I}", "Î"},
		{"\\\"{I}", "Ï"},
		{"\\k{I}", "Į"},
		{"\\~{N}", "Ñ"},
		{"\\`{O}", "Ò"},
		{"\\'{O}", "Ó"},
		{"\\^{O}", "Ô"},
		{"\\~{O}", "Õ"},
		{"\\\"{O}", "Ö"},
		{"\\H{O}", "Ő"},
		{"\\OE{}", "Œ"},
		{"\\OE ", "Œ"},
		{"\\`{U}", "Ù"},
		{"\\'{U}", "Ú"},
		{"\\^{U}", "Û"},
		{"\\\"{U}", "Ü"},
		{"\\H{U}", "Ű"},
		{"\\k{U}", "Ų"},
		{"\\'{Y}", "Ý"},
		{"\\\"{Y}", "Ÿ"},
		{"\\`{a}", "à"},
		{"\\'{a}", "á"},
		{"\\^{a}", "â"},
		{"\\~{a}", "ã"},
		{"\\\"{a}", "ä"},
		{"\\k{a}", "ą"},
		{"\\ae{}", "æ"},
		{"\\ae ", "æ"},
		{"\\c{c}", "ç"},
		{"\\c c", "ç"},
		{"\\`{e}", "è"},
		{"\\'{e}", "é"},
		{"\\^{e}", "ê"},
		{"\\\"{e}", "ë"},
		{"\\k{e}", "ę"},
		{"\\`{\\i}", "ı̀"},
		{"\\'{\\i}", "ı́"},
		{"\\^{\\i}", "ı̂"},
		{"\\\"{\\i}", "ı̈"},
		{"\\k{i}", "į"},
		{"\\~{n}", "ñ"},
		{"\\`{o}", "ò"},
		{"\\'{o}", "ó"},
		{"\\^{o}", "ô"},
		{"\\~{o}", "õ"},
		{"\\\"{o}", "ö"},
		{"\\H{o}", "ő"},
		{"\\oe{}", "œ"},
		{"\\oe ", "œ"},
		{"\\`{u}", "ù"},
		{"\\'{u}", "ú"},
		{"\\^{u}", "û"},
		{"\\\"{u}", "ü"},
		{"\\H{u}", "ű"},
		{"\\k{u}", "ų"},
		{"\\'{y}", "ý"},
		{"\\\"{y}", "ÿ"},
		{"\\`A", "À"},
		{"\\'A", "Á"},
		{"\\^A", "Â"},
		{"\\~A", "Ã"},
		{"\\\"A", "Ä"},
		{"\\`E", "È"},
		{"\\'E", "É"},
		{"\\^E", "Ê"},
		{"\\\"E", "Ë"},
		{"\\`I", "Ì"},
		{"\\'I", "Í"},
		{"\\^I", "Î"},
		{"\\\"I", "Ï"},
		{"\\~N", "Ñ"},
		{"\\`O", "Ò"},
		{"\\'O", "Ó"},
		{"\\^O", "Ô"},
		{"\\~O", "Õ"},
		{"\\\"O", "Ö"},
		{"\\`U", "Ù"},
		{"\\'U", "Ú"},
		{"\\^U", "Û"},
		{"\\\"U", "Ü"},
		{"\\'Y", "Ý"},
		{"\\\"Y", "Ÿ"},
		{"\\`a", "à"},
		{"\\'a", "á"},
		{"\\^a", "â"},
		{"\\~a", "ã"},
		{"\\\"a", "ä"},
		{"\\`e", "è"},
		{"\\'e", "é"},
		{"\\^e", "ê"},
		{"\\\"e", "ë"},
		{"\\`\\i", "ı̀"},
		{"\\'\\i", "ı́"},
		{"\\^\\i", "ı̂"},
		{"\\\"\\i", "ı̈"},
		{"\\~n", "ñ"},
		{"\\`o", "ò"},
		{"\\'o", "ó"},
		{"\\^o", "ô"},
		{"\\~o", "õ"},
		{"\\\"o", "ö"},
		{"\\`u", "ù"},
		{"\\'u", "ú"},
		{"\\^u", "û"},
		{"\\\"u", "ü"},
		{"\\'y", "ý"},
		{"\\\"y", "ÿ"},
	}

	var out bytes.Buffer // the output writer
	for i, d := range data {
		out.Reset()
		in := strings.NewReader(d.in)
		if got := ToUnicode(&out, in); got != nil {
			t.Errorf("test %d: ToUnicode(%q) = %v, want nil", i, d.in, got)
		}
		if out.String() != d.out {
			t.Errorf("test %d: ToUnicode(%q) = %q, want %q", i, d.in, out.String(), d.out)
		}
	}
}

func TestToLaTeX(t *testing.T) {
	data := []struct {
		in, out string
	}{
		{"ø", "{\\o}"},
		{"Ø", "{\\O}"},
		{"À", "\\`A"},
		{"Á", "\\'A"},
		{"Â", "\\^A"},
		{"Ã", "\\~A"},
		{"Ä", "\\\"A"},
		{"Å", "{\\AA}"},
		{"Æ", "{\\AE}"},
		{"Ą", "\\k{A}"},
		{"Ç", "\\c{C}"},
		{"È", "\\`E"},
		{"É", "\\'E"},
		{"Ê", "\\^E"},
		{"Ë", "\\\"E"},
		{"Ę", "\\k{E}"},
		{"Ì", "\\`I"},
		{"Í", "\\'I"},
		{"Î", "\\^I"},
		{"Ï", "\\\"I"},
		{"Į", "\\k{I}"},
		{"Ñ", "\\~N"},
		{"Ò", "\\`O"},
		{"Ó", "\\'O"},
		{"Ô", "\\^O"},
		{"Õ", "\\~O"},
		{"Ö", "\\\"O"},
		{"Ő", "\\H{O}"},
		{"Œ", "{\\OE}"},
		{"Ù", "\\`U"},
		{"Ú", "\\'U"},
		{"Û", "\\^U"},
		{"Ü", "\\\"U"},
		{"Ű", "\\H{U}"},
		{"Ų", "\\k{U}"},
		{"Ý", "\\'Y"},
		{"Ÿ", "\\\"Y"},
		{"ß", "{\\ss}"},
		{"à", "\\`a"},
		{"á", "\\'a"},
		{"â", "\\^a"},
		{"ã", "\\~a"},
		{"ä", "\\\"a"},
		{"å", "{\\aa}"},
		{"ą", "\\k{a}"},
		{"æ", "{\\ae}"},
		{"ç", "\\c{c}"},
		{"è", "\\`e"},
		{"é", "\\'e"},
		{"ê", "\\^e"},
		{"ë", "\\\"e"},
		{"ę", "\\k{e}"},
		{"ì", "\\`{\\i}"},
		{"í", "\\'{\\i}"},
		{"î", "\\^{\\i}"},
		{"ï", "\\\"{\\i}"},
		{"į", "\\k{i}"},
		{"ñ", "\\~n"},
		{"ò", "\\`o"},
		{"ó", "\\'o"},
		{"ô", "\\^o"},
		{"õ", "\\~o"},
		{"ö", "\\\"o"},
		{"ő", "\\H{o}"},
		{"œ", "{\\oe}"},
		{"ù", "\\`u"},
		{"ú", "\\'u"},
		{"û", "\\^u"},
		{"ü", "\\\"u"},
		{"ű", "\\H{u}"},
		{"ų", "\\k{u}"},
		{"ý", "\\'y"},
		{"ÿ", "\\\"y"},
	}
	context := []string{
		"%s",
		"before %s",
		"%s after",
		"before %s after",
	}

	var out bytes.Buffer // the output writer
	for i, d := range data {
		for j, c := range context {
			out.Reset()
			inc := fmt.Sprintf(c, d.in)
			in := strings.NewReader(inc)
			if got := ToLaTeX(&out, in); got != nil {
				t.Errorf("test %d.%d: ToLaTeX(%q) = %v, want nil", i, j, inc, got)
			}
			want := fmt.Sprintf(c, d.out)
			if out.String() != want {
				t.Errorf("test %d.%d: ToLaTeX(%q) = %q, want %q", i, j, inc, out.String(), want)
			}
		}
	}
}
